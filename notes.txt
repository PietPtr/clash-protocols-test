kan je een AXI4 Domain maken zoals er ook een Signal domain is? zie Signal/Internal.hs en hoe de KnownDomain en KnownConf gedaan zijn. Dan ben je ook van die gigantische datatypes af met superveel type variables.

###

Waarom deden we ook alweer type injectivity?
- type inference

Hoe zit het met "dropped" transactions? Als de master minder vaak ready is dan dat ie AR drivet kan je dingen missen toch?
- je dropped ze niet, je zet je ready voor nieuwe transacties op false (backpressure geven), precies wat ik eigenlijk al deed in het example voor axi4lite.

Waar zijn strict tuples voor? Performance.

Samen naar TwoWayDf kijken: werkt inderdaad niet zo lekker op die manier

Haddock?
- bouwen doet de CI
- of doe cabal haddock, dat werkt nu.

###

een FIFO kan gemaakt worden die transacties vasthoudt en doorgeeft, en dan in AXI aangeeft of ie vol zit en zo. Daarna kunnen daar Hedgehog tests voor gebouwd worden: de pure versie van een FIFO is namelijk simpelweg `id`.

###

Gaan we de channels instances maken van DfLike?
  simulate voor ReadData gaat de verkeerde kant op
  Onmogelijk, DfLike wil een `df :: Type -> Type`, en de meeste axi4(lite) types nemen geen type als laatste argument (e.g. :kind (Axi4LiteRA dom) :: AddrWidth -> Type)

Hmmm hoe abstracten we de fifo voor de andere channels? Je zou bijna een FIFO aan Df gaan toevoegen ipv per channel aan AXI. (Moet AXI wel goed als DfLike kunnen werken...)

Wat doet een ~ voor een lijst pattern? regel 821 DfLike.hs

We zouden Df dom AxiType kunnen doen, de types die daar uitkomen zijn isomorphisch aan de types die we nu hebben. Wel wordt xready dan Ack genoemd, en ik heb het gevoel dat die semantics niet overeen komen met Axi.

AxiLike, voor een unit die ready in plaats van Ack gebruikt? of zijn die toch hetzelfde?

Waarom gebruik jij <> en niet ++? Is het omdat ++ door zowel clash als prelude wordt ge-export?

pred (s :: Int) ipv (s - 1), zit daar meer achter?

catDatas â‰… catMaybes . toMaybe oid
