kan je een AXI4 Domain maken zoals er ook een Signal domain is? zie Signal/Internal.hs en hoe de KnownDomain en KnownConf gedaan zijn. Dan ben je ook van die gigantische datatypes af met superveel type variables.

###

Waarom deden we ook alweer type injectivity?
- type inference

Hoe zit het met "dropped" transactions? Als de master minder vaak ready is dan dat ie AR drivet kan je dingen missen toch?
- je dropped ze niet, je zet je ready voor nieuwe transacties op false (backpressure geven), precies wat ik eigenlijk al deed in het example voor axi4lite.

Waar zijn strict tuples voor? Performance.

Samen naar TwoWayDf kijken: werkt inderdaad niet zo lekker op die manier

Haddock?
- bouwen doet de CI
- of doe cabal haddock, dat werkt nu.

###

een FIFO kan gemaakt worden die transacties vasthoudt en doorgeeft, en dan in AXI aangeeft of ie vol zit en zo. Daarna kunnen daar Hedgehog tests voor gebouwd worden: de pure versie van een FIFO is namelijk simpelweg `id`.

###

Gaan we de channels instances maken van DfLike?
  simulate voor ReadData gaat de verkeerde kant op
  Onmogelijk, DfLike wil een `df :: Type -> Type`, en de meeste axi4(lite) types nemen geen type als laatste argument (e.g. :kind (Axi4LiteRA dom) :: AddrWidth -> Type)

Hmmm hoe abstracten we de fifo voor de andere channels? Je zou bijna een FIFO aan Df gaan toevoegen ipv per channel aan AXI. (Moet AXI wel goed als DfLike kunnen werken...)

We zouden Df dom AxiType kunnen doen, de types die daar uitkomen zijn isomorphisch aan de types die we nu hebben. Wel wordt xready dan Ack genoemd, en ik heb het gevoel dat die semantics niet overeen komen met Axi.

AxiLike, voor een unit die ready in plaats van Ack gebruikt? of zijn die toch hetzelfde? -> Vind ik misschien een best goed idee eigenlijk.

In het hele Df dom AxiType idee vraag ik me af of dit blijft werken:
- Once asserted, a source must keep a high xVALID until a handshake occurs.

Waarom gebruik jij <> en niet ++? Is het omdat ++ door zowel clash als prelude wordt ge-export? -> Ja.

pred (s :: Int) ipv (s - 1), zit daar meer achter?

catDatas â‰… catMaybes . toMaybe oid

Waarom - 5 in de true branch van eoDriveEarly?

  Fout in mijn driveWA (driveC implementatie):
  > take 140 $ simulateC dfDriver def ()
  levert 100x NoData op, 1x Data 4, en daarna oneindig NoData. (NewDfTest.hs)
  [_,_,_,...,_,_,d,_,_,_,_,_,_,...]

  >  P.take 140 $ simulateC someDriver def ()
  levert 100x NoWriteAddress op (so far so good), en dan het patroon WriteAddress NoWriteAddress, oneindig herhalend. Clearly niet hetzelfde behaviour.
  [_,_,_,...,_,_,d,_,d,_,d,_,d,...]
  Dit was inderdaad een bug in de empty list case van de go in driveWA. Gefixt, behaviour is nu hetzelfde.

[of rhs hanging nou is opgelost of niet] Ik ben al een paar keer tegengekomen dat de simulatie hangt, meestal (denk ik) doordat er ergens toch een combinatorial feedback loop in zit. Hoe kan ik die debuggen? HDL genereren lijkt gewoon te kunnen, wat me raar lijkt als er daadwerkelijk een loop in zit, ik dacht dat Clash daar op checkte. -> Clash vindt alleen de meest obvious cases, eigenlijk moet dit met profiling gedaan worden, maar de profiling van GHC is al vijf jaar stuk.

Waarom wordt er een clock in m'n verilog gegenereerd (Iets met System domain denk ik)
Wanneer exposedAxiFIFO bestaat wordt ie ook gesynthesized, is dat omdat ie in het domain System zit? -> Was een bug in Clash, die zit nog niet in 1.4.6. Niet erg belangrijk verder ook.

Simulation Termination:
Los lijken rhsStallC en exposedAxiFIFO prima te werken, maar zodra ze aan elkaar gekoppeld gesimuleerd worden terminate het niet:
> mapM_ print $ zip [1..] $ P.take 32 $ simulateC (exposedAxiFIFO) (def {resetCycles = 30}) [m2swa 4]
(1,M2S_NoWriteAddress)
...
(32,M2S_WriteAddress {_awaddr = 0100, _awprot = (NotPrivileged,NonSecure,Data)})

> mapM_ print $ zip [1..] $ P.take 32 $ simulateC (rhsStallC) (def {resetCycles = 30}) [m2swa 4]
(1,M2S_NoWriteAddress)
...
(31,M2S_WriteAddress {_awaddr = 0100, _awprot = (NotPrivileged,NonSecure,Data)})

> mapM_ print $ zip [1..] $ P.take 32 $ simulateC (exposedAxiFIFO |> rhsStallC) (def {resetCycles = 30}) [m2swa 4]
(1,M2S_NoWriteAddress)
...
(31,^CInterrupted.


###


data WriteAddress (aw :: AddrWidth)
  = WriteAddress {
    _awaddr' :: !(C.BitVector (Width aw)),
    _awprot' :: PermissionsType 'KeepPermissions
  }

type Axi4LiteWA'
  (dom :: C.Domain)
  (aw :: AddrWidth) = Df dom (WriteAddress aw)
