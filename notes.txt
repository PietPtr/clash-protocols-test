kan je een AXI4 Domain maken zoals er ook een Signal domain is? zie Signal/Internal.hs en hoe de KnownDomain en KnownConf gedaan zijn. Dan ben je ook van die gigantische datatypes af met superveel type variables.

###

Waarom deden we ook alweer type injectivity?
- type inference

Hoe zit het met "dropped" transactions? Als de master minder vaak ready is dan dat ie AR drivet kan je dingen missen toch?
- je dropped ze niet, je zet je ready voor nieuwe transacties op false (backpressure geven), precies wat ik eigenlijk al deed in het example voor axi4lite.

Waar zijn strict tuples voor? Performance.

Samen naar TwoWayDf kijken: werkt inderdaad niet zo lekker op die manier

Haddock?
- bouwen doet de CI
- of doe cabal haddock, dat werkt nu.

###

een FIFO kan gemaakt worden die transacties vasthoudt en doorgeeft, en dan in AXI aangeeft of ie vol zit en zo. Daarna kunnen daar Hedgehog tests voor gebouwd worden: de pure versie van een FIFO is namelijk simpelweg `id`.

###

Gaan we de channels instances maken van DfLike?
  simulate voor ReadData gaat de verkeerde kant op
  Onmogelijk, DfLike wil een `df :: Type -> Type`, en de meeste axi4(lite) types nemen geen type als laatste argument (e.g. :kind (Axi4LiteRA dom) :: AddrWidth -> Type)

Hmmm hoe abstracten we de fifo voor de andere channels? Je zou bijna een FIFO aan Df gaan toevoegen ipv per channel aan AXI. (Moet AXI wel goed als DfLike kunnen werken...)

We zouden Df dom AxiType kunnen doen, de types die daar uitkomen zijn isomorphisch aan de types die we nu hebben. Wel wordt xready dan Ack genoemd, en ik heb het gevoel dat die semantics niet overeen komen met Axi.

AxiLike, voor een unit die ready in plaats van Ack gebruikt? of zijn die toch hetzelfde? -> Vind ik misschien een best goed idee eigenlijk.

In het hele Df dom AxiType idee vraag ik me af of dit blijft werken:
- Once asserted, a source must keep a high xVALID until a handshake occurs.

Waarom gebruik jij <> en niet ++? Is het omdat ++ door zowel clash als prelude wordt ge-export? -> Ja.

pred (s :: Int) ipv (s - 1), zit daar meer achter?

catDatas â‰… catMaybes . toMaybe oid

Waarom - 5 in de true branch van eoDriveEarly?

  Fout in mijn driveWA (driveC implementatie):
  > take 140 $ simulateC dfDriver def ()
  levert 100x NoData op, 1x Data 4, en daarna oneindig NoData. (NewDfTest.hs)
  [_,_,_,...,_,_,d,_,_,_,_,_,_,...]

  >  P.take 140 $ simulateC someDriver def ()
  levert 100x NoWriteAddress op (so far so good), en dan het patroon WriteAddress NoWriteAddress, oneindig herhalend. Clearly niet hetzelfde behaviour.
  [_,_,_,...,_,_,d,_,d,_,d,_,d,...]
  Dit was inderdaad een bug in de empty list case van de go in driveWA. Gefixt, behaviour is nu hetzelfde.

[of rhs hanging nou is opgelost of niet] Ik ben al een paar keer tegengekomen dat de simulatie hangt, meestal (denk ik) doordat er ergens toch een combinatorial feedback loop in zit. Hoe kan ik die debuggen? HDL genereren lijkt gewoon te kunnen, wat me raar lijkt als er daadwerkelijk een loop in zit, ik dacht dat Clash daar op checkte. -> Clash vindt alleen de meest obvious cases, eigenlijk moet dit met profiling gedaan worden, maar de profiling van GHC is al vijf jaar stuk.

Waarom wordt er een clock in m'n verilog gegenereerd (Iets met System domain denk ik)
Wanneer exposedAxiFIFO bestaat wordt ie ook gesynthesized, is dat omdat ie in het domain System zit? -> Was een bug in Clash, die zit nog niet in 1.4.6. Niet erg belangrijk verder ook.

Simulation Termination:
Los lijken rhsStallC en exposedAxiFIFO prima te werken, maar zodra ze aan elkaar gekoppeld gesimuleerd worden terminate het niet:
> mapM_ print $ zip [1..] $ P.take 32 $ simulateC (exposedAxiFIFO) (def {resetCycles = 30}) [m2swa 4]
(1,M2S_NoWriteAddress)
...
(32,M2S_WriteAddress {_awaddr = 0100, _awprot = (NotPrivileged,NonSecure,Data)})

> mapM_ print $ zip [1..] $ P.take 32 $ simulateC (rhsStallC) (def {resetCycles = 30}) [m2swa 4]
(1,M2S_NoWriteAddress)
...
(31,M2S_WriteAddress {_awaddr = 0100, _awprot = (NotPrivileged,NonSecure,Data)})

> mapM_ print $ zip [1..] $ P.take 32 $ simulateC (exposedAxiFIFO |> rhsStallC) (def {resetCycles = 30}) [m2swa 4]
(1,M2S_NoWriteAddress)
...
(31,^CInterrupted.


###

volgens mij is SimulateFwdType gewoon Fwd, similarly met Bwd: dat is het niet, want protocol types zijn vaak van een signal achtig geval, en simulate type is dan een list daarvan. Msch kan je dat met typelezvel crap wel inferren, maar dan hou je die ()-case waar de simulate type uberhaupt geen list is.

richtingen? (sampleFwd hoeft alleen voor fwd te bestaan, dat is een weird artifact wat me niet goed ligt)

type Axi4LiteWA'
  (dom :: C.Domain)
  (aw :: AddrWidth) = Df dom (WriteAddress aw)



1. Register ertussen gooien
axiRegister maken is gelukt, door gewoon te kijken naar registerFwd. Tests slagen gewoon bij deze.

2. dezelfde FIFO in Df maken.
Zelfde problemen als de axiFIFO, dus er zal ergens bij de aan-elkaar-knoop-logica iets mis aan het gaan zijn.

registerFwd gedraagt zich als een ready ipv een Ack:
Clash.Prelude Protocols Protocols.Df> Clash.Prelude.simulate sys [(NoData, Ack False), (NoData, Ack False)]
[(Ack True,NoData),(Ack True,NoData),(Ack True,NoData),(Ack *** Exception: X: finite list

fanout gedraagt zich alleen wel als Ack...


Simulate werkt niet voor Axi omdat Axi meer dan alleen Acks terugstuurt. Volle Axi zou hebben:
  - Fwd: WA, WD, RA datas, WR, RD readies
  - Bwd: WR, RD datas, WA, WD, RA readies
Omdat tuples en vectors de boolToBwd gebruiken, en de Bwd veel ingewikkelder is dan een bool, moet er een ander soort simulate class zijn. Deze class heeft dan een driveFwd en driveBwd. een simulateC-achtige functie krijgt dan een SimulateType voor zowel de Bwd als de Fwd (dus twee lijsten aan simulation inputs).

class Simulate2 a where
  type SimulateTypeFwd a :: Type
  type SimulateTypeBwd a :: Type
  -- nog even geen expect type
  -- en die channels skip ik nu ook even
  driveFwd ::
    SimulationConfig ->
    SimulateTypeFwd a ->
    Fwd a

  driveBwd ::
    SimulationConfig ->
    SimulateTypeBwd a ->
    Bwd a

  drive ::
    SimulationConfig ->
    SimulateTypeFwd a ->
    SimulateTypeBwd a ->
    (Fwd a, Bwd a)
simulateC' @(Df System Int) @(Df System Int)
  :: SimulationConfig
     -> [Protocols.Df.Data Int]
     -> [Protocols.Ack]
     -> Circuit (Df System Int) (Df System Int)
     -> ([Protocols.Ack], [Protocols.Df.Data Int])

Zou dus twee lijsten van gelijke lengte geven met de acks die aan links uit het systeem komen, en de data die aan rechts verstuurd wordt. Die twee hebben dus niet bijster veel met elkaar te maken, omdat er net zo goed ook een ander protocol had kunnen staan.

> let circ = idC @(Df System Int)
> simulateC' @(Df System Int) @(Df System Int) def [NoData, NoData, Protocols.Df.Data 1] [Ack True, Ack False, Ack True] circ

[Ack True,Ack False,Ack True*** Exception: X: finite list
[NoData,NoData,Data 1*** Exception: X: finite list

Ziet er wel prima uit denk ik, behalve natuurlijk dat ie zich niet aan de simulationconfig houdt.

###

Moet droppingDriveBwdC @(Df dom a) rekening houden met acks? Ik zou zeggen van niet.

In tests/ staat een bestand met tests voor df, daar kunnen we de simulate functies testen.

Ik kan in Hedgehog.hs een nieuwe functie bouwen om tests mee te genereren die dus gegeven

Simulate herschrijven voor Circuit () a en Circuit a (), aangezien dat de enige zijn die we nodig gaan hebben voor AXI. Een processor kan dan bijvoorbeeld van type Circuit () (Axi, s) zijn, waar s een ander signal is. Een slave van type Circuit Axi () kan dan daarmee verbonden worden via de Circuit notation plugin, zodat dat andere stukje signal er nog uitgehaald kan worden om bijvoorbeeld IO te driven.

```haskell
>> :t simulateManager @(Df System Int)
simulateManager @(Df System Int)
  :: SimulationConfig
     -> [Protocols.Ack]
     -> Circuit () (Df System Int)
     -> [Protocols.Df.Data Int]

>> :t simulateSubordinate @(Df System Int)
simulateSubordinate @(Df System Int)
  :: SimulationConfig
     -> [Protocols.Df.Data Int]
     -> Circuit (Df System Int) ()
     -> [Protocols.Ack]
```


simulateManager lijkt te werken, simulateSubordinate wordt er niet goed gekeken naar de Acks die die terugkrijgt. Een lastig stukje daar is dat zowel de acks gereturned moeten worden als dat ze op invloed moeten zijn van welke data gedrived wordt.

ik wil wel wat meer weten over ignoreReset in SimulationConfig. Hij lijkt specifiek te zijn voor sampleC.

Dingen te doen zonder Martijn:
[x] simulationconfig voor Df Simulate instance implementeren
[x] documentatie simulate(M|S)
[x] Spannende merge van simulate branch naar axi4-lite
[x] Axi4Lite als 1 record datatype bouwen
[x] simulateManager implementeren voor Axi4Lite
[x] simulateSubordinate implementeren voor Axi4Lite
[x] Show instance voor M2S_Axi4Lite en S2M_Axi4Lite
[x] Testcode die simulateManager gebruikt maken
[x] Testcode die simulateSubordinate gebruikt maken
[-] WaveDrom dingen instellen en gebruiken
[ ] Een voorbeeld zien te bouwen wat een Axi master en slave verbindt, maar nog data 'exporteert'
[ ] Optie 1. Alle Simulate instances volledig implementeren.
    Optie 2. Simulate uit elkaar trekken in 2 classes.

Betere moduleverdeling voor Axi4Lite? Nu staan alle types en instances in 1 bestand, en dat is ook eigenlijk alles wat er is. Splitsen we dat uit? Het opsplitsen per channel zoals in grote axi lijkt me voor Axi lite nogal veer noise.

SimulateChannels wil ik naar kijken, is dat nuttig voor AXI?

In reset, ben je dan ready of niet? Ik zou zeggen van niet.

Er gaat iets goed mis in het deriven van de NFDataX instance ergens... (fromList_lazy fixte het, waarom heeft die nou weer geen NFDataX nodig...)

gewoon zo'n ding bouwen wat van die wikipedia-style diagrammen genereert gegeven een lijst M2S en S2M, daar bestaat een text based formaat voor (wavedrom)

```haskell
-- schrijft meteen dat hele diagram weg naar een file
generateDiagram :: [M2S_Axi4Lite aw bw] -> [S2M_Axi4Lite aw bw] -> WaveDiagram
```

Ik denk dat het beter is om simulate(L|R) in een andere class te zetten, aangezien er voor AXI niet echt chill een Simulate class gemaakt kan worden, en voor Df simulate(L|R) absoluut niet nuttig zijn.

Ik had graag protocols-test verder opgezet, maar cabal geeft heel vervelende errors met WaveDrom :/
